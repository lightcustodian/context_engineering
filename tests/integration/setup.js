// Integration test setup
// Generated by Context Engineering Feature Request Decomposition System

const fs = require('fs');
const path = require('path');

// Global test setup for integration tests
beforeAll(async () => {
  console.log('🚀 Setting up integration test environment...');
  
  // Initialize test directories
  await initializeTestDirectories();
  
  // Setup test data
  await setupTestData();
  
  // Initialize feature registry for testing
  await initializeTestFeatureRegistry();
  
  console.log('✅ Integration test environment ready');
});

afterAll(async () => {
  console.log('🧹 Cleaning up integration test environment...');
  
  // Cleanup test data
  await cleanupTestData();
  
  // Remove temporary test files
  await cleanupTemporaryFiles();
  
  console.log('✅ Integration test environment cleaned up');
});

// Setup functions
async function initializeTestDirectories() {
  const testDirs = [
    'tests/integration/temp',
    'tests/integration/fixtures',
    'tests/integration/output'
  ];
  
  for (const dir of testDirs) {
    if (!fs.existsSync(dir)) {
      fs.mkdirSync(dir, { recursive: true });
    }
  }
}

async function setupTestData() {
  // Create test feature registry
  const testRegistry = {
    version: "1.0.0",
    project_id: "integration-test-project",
    created: new Date().toISOString(),
    last_updated: new Date().toISOString(),
    features: [
      {
        id: "FR-001",
        name: "Test Feature A",
        file_path: "tests/integration/fixtures/FR-001-test-feature-a.md",
        status: "completed",
        dependencies: [],
        dependents: ["FR-002"],
        confidence_score: 0.9,
        integration_points: ["data-model", "api-endpoint"],
        validation_gates: {
          pre_implementation: true,
          implementation: true,
          post_implementation: true
        }
      },
      {
        id: "FR-002",
        name: "Test Feature B",
        file_path: "tests/integration/fixtures/FR-002-test-feature-b.md",
        status: "in_progress",
        dependencies: ["FR-001"],
        dependents: [],
        confidence_score: 0.7,
        integration_points: ["data-model", "user-interface"],
        validation_gates: {
          pre_implementation: true,
          implementation: false,
          post_implementation: false
        }
      }
    ],
    dependency_graph: {
      "FR-001": [],
      "FR-002": ["FR-001"]
    },
    execution_order: ["FR-001", "FR-002"],
    overall_progress: {
      total_features: 2,
      completed_features: 1,
      completion_percentage: 50,
      overall_confidence: 0.8
    }
  };
  
  // Save test registry
  const registryPath = 'tests/integration/fixtures/test-feature-registry.json';
  fs.writeFileSync(registryPath, JSON.stringify(testRegistry, null, 2), 'utf8');
  
  // Create test feature files
  await createTestFeatureFiles();
}

async function createTestFeatureFiles() {
  const featureAContent = `# FR-001: Test Feature A

## User Story
As a test user, I want to test feature interactions, so that I can verify the integration testing framework works correctly.

## Acceptance Criteria
1. Feature A should initialize correctly
2. Feature A should provide data to Feature B
3. Feature A should handle errors gracefully

## Validation Gates
- Pre-implementation: Requirements validated ✅
- Implementation: Unit tests pass ✅
- Post-implementation: Integration tests pass ✅

## Integration Points
- Data model shared with other features
- API endpoint for external access
`;

  const featureBContent = `# FR-002: Test Feature B

## User Story
As a test user, I want Feature B to work with Feature A, so that I can test cross-feature functionality.

## Acceptance Criteria
1. Feature B should receive data from Feature A
2. Feature B should process data correctly
3. Feature B should update the user interface

## Validation Gates
- Pre-implementation: Requirements validated ✅
- Implementation: Unit tests pass ❌
- Post-implementation: Integration tests pass ❌

## Integration Points
- Data model shared with Feature A
- User interface components
`;

  fs.writeFileSync('tests/integration/fixtures/FR-001-test-feature-a.md', featureAContent, 'utf8');
  fs.writeFileSync('tests/integration/fixtures/FR-002-test-feature-b.md', featureBContent, 'utf8');
}

async function initializeTestFeatureRegistry() {
  // Set environment variable for test registry path
  process.env.TEST_FEATURE_REGISTRY_PATH = 'tests/integration/fixtures/test-feature-registry.json';
}

async function cleanupTestData() {
  // Remove test registry
  const registryPath = 'tests/integration/fixtures/test-feature-registry.json';
  if (fs.existsSync(registryPath)) {
    fs.unlinkSync(registryPath);
  }
  
  // Remove test feature files
  const featureFiles = [
    'tests/integration/fixtures/FR-001-test-feature-a.md',
    'tests/integration/fixtures/FR-002-test-feature-b.md'
  ];
  
  for (const file of featureFiles) {
    if (fs.existsSync(file)) {
      fs.unlinkSync(file);
    }
  }
}

async function cleanupTemporaryFiles() {
  const tempDir = 'tests/integration/temp';
  if (fs.existsSync(tempDir)) {
    const files = fs.readdirSync(tempDir);
    for (const file of files) {
      fs.unlinkSync(path.join(tempDir, file));
    }
  }
  
  const outputDir = 'tests/integration/output';
  if (fs.existsSync(outputDir)) {
    const files = fs.readdirSync(outputDir);
    for (const file of files) {
      fs.unlinkSync(path.join(outputDir, file));
    }
  }
}

// Global test utilities
global.getTestFeatureRegistry = () => {
  const registryPath = process.env.TEST_FEATURE_REGISTRY_PATH;
  if (fs.existsSync(registryPath)) {
    return JSON.parse(fs.readFileSync(registryPath, 'utf8'));
  }
  return null;
};

global.createTestFeature = (id, name, dependencies = []) => {
  return {
    id,
    name,
    file_path: `tests/integration/fixtures/${id}-${name.toLowerCase().replace(/\s+/g, '-')}.md`,
    status: "planned",
    dependencies,
    dependents: [],
    confidence_score: 0.0,
    integration_points: ["test-integration"],
    validation_gates: {
      pre_implementation: false,
      implementation: false,
      post_implementation: false
    }
  };
};

global.waitForAsync = (ms = 100) => {
  return new Promise(resolve => setTimeout(resolve, ms));
};

// Mock implementations for testing
global.mockFeatureImplementation = {
  createData: async (featureId, data) => {
    return { id: `${featureId}-${Date.now()}`, ...data };
  },
  
  getData: async (featureId, dataId) => {
    return { id: dataId, featureId, retrieved: true };
  },
  
  updateData: async (featureId, dataId, updates) => {
    return { id: dataId, featureId, ...updates, updated: true };
  },
  
  deleteData: async (featureId, dataId) => {
    return { id: dataId, featureId, deleted: true };
  }
};

console.log('📋 Integration test setup completed');