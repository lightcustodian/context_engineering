// Integration test for the enhanced validation system
// Tests Task 7: Enhanced /validate command with feature-specific validation
// Generated by Context Engineering Feature Request Decomposition System

const fs = require('fs');
const path = require('path');

describe('Enhanced Validation System Integration', () => {
  let mockRegistry;
  let ValidationManager;
  let ValidationStateManager;
  let ValidationReporter;
  let IntegrationTestManager;

  beforeAll(async () => {
    // Import the validation system components
    ({ ValidationManager } = require('../../.claude/system/validation_manager'));
    ({ ValidationStateManager } = require('../../.claude/system/validation_state_manager'));
    ({ ValidationReporter } = require('../../.claude/system/validation_reporter'));
    ({ IntegrationTestManager } = require('../../.claude/system/integration_test_manager'));
  });

  beforeEach(() => {
    // Create mock feature registry
    mockRegistry = {
      version: "1.0.0",
      project_id: "test-project",
      created: "2025-01-17T10:00:00Z",
      last_updated: "2025-01-17T11:30:00Z",
      features: [
        {
          id: "FR-001",
          name: "Basic Task CRUD",
          file_path: "2-docs/features/FR-001-basic-task-crud.md",
          status: "in_progress",
          dependencies: [],
          dependents: ["FR-003"],
          confidence_score: 0.8,
          validation_gates: {
            pre_implementation: true,
            implementation: false,
            post_implementation: false
          }
        },
        {
          id: "FR-002",
          name: "Task Hierarchy System",
          file_path: "2-docs/features/FR-002-task-hierarchy-system.md",
          status: "planned",
          dependencies: ["FR-001"],
          dependents: ["FR-003"],
          confidence_score: 0.0,
          validation_gates: {
            pre_implementation: false,
            implementation: false,
            post_implementation: false
          }
        },
        {
          id: "FR-003",
          name: "Daily Calendar View",
          file_path: "2-docs/features/FR-003-daily-calendar-view.md",
          status: "planned",
          dependencies: ["FR-001", "FR-002"],
          dependents: [],
          confidence_score: 0.0,
          validation_gates: {
            pre_implementation: false,
            implementation: false,
            post_implementation: false
          }
        }
      ],
      dependency_graph: {
        "FR-001": [],
        "FR-002": ["FR-001"],
        "FR-003": ["FR-001", "FR-002"]
      },
      execution_order: ["FR-001", "FR-002", "FR-003"],
      overall_progress: {
        total_features: 3,
        completed_features: 0,
        completion_percentage: 0,
        overall_confidence: 0.27
      }
    };
  });

  describe('ValidationManager', () => {
    test('should initialize from registry', async () => {
      const validationManager = await ValidationManager.fromRegistry(mockRegistry);
      
      expect(validationManager).toBeDefined();
      expect(validationManager.registry).toEqual(mockRegistry);
    });

    test('should validate features with different options', async () => {
      const validationManager = await ValidationManager.fromRegistry(mockRegistry);
      
      // Test basic validation
      const results = await validationManager.validateFeatures(['FR-001'], {});
      
      expect(results).toBeDefined();
      expect(results.total_features).toBe(1);
      expect(results.features).toHaveLength(1);
      expect(results.features[0].id).toBe('FR-001');
      expect(results.test_results.unit).toBeDefined();
    });

    test('should handle integration test validation', async () => {
      const validationManager = await ValidationManager.fromRegistry(mockRegistry);
      
      const results = await validationManager.validateFeatures(['FR-001'], { 
        integration: true 
      });
      
      expect(results.test_results.integration).toBeDefined();
    });

    test('should calculate confidence scores correctly', async () => {
      const validationManager = await ValidationManager.fromRegistry(mockRegistry);
      
      const mockFeatureResult = {
        test_results: {
          unit: { total: 10, passed: 8, failed: 2, skipped: 0 },
          integration: { total: 5, passed: 4, failed: 1, skipped: 0 }
        },
        validation_gates: {
          pre_implementation: true,
          implementation: true,
          post_implementation: false
        }
      };
      
      const confidenceScore = validationManager.calculateConfidenceScore(mockFeatureResult);
      
      expect(confidenceScore).toBeGreaterThan(0);
      expect(confidenceScore).toBeLessThanOrEqual(1);
    });
  });

  describe('ValidationReporter', () => {
    test('should generate comprehensive validation reports', () => {
      const reporter = new ValidationReporter();
      
      const mockResults = {
        timestamp: new Date().toISOString(),
        total_features: 2,
        passed_features: 1,
        failed_features: 1,
        skipped_features: 0,
        test_results: {
          unit: { total: 15, passed: 12, failed: 3, skipped: 0 }
        },
        features: [
          {
            id: 'FR-001',
            name: 'Basic Task CRUD',
            passed: true,
            validation_status: 'passed',
            confidence_score: 0.8,
            validation_gates: {
              pre_implementation: true,
              implementation: true,
              post_implementation: false
            },
            test_results: {
              unit: { total: 10, passed: 10, failed: 0, skipped: 0 }
            },
            validation_errors: []
          },
          {
            id: 'FR-002',
            name: 'Task Hierarchy System',
            passed: false,
            validation_status: 'failed',
            confidence_score: 0.4,
            validation_gates: {
              pre_implementation: true,
              implementation: false,
              post_implementation: false
            },
            test_results: {
              unit: { total: 5, passed: 2, failed: 3, skipped: 0 }
            },
            validation_errors: ['3 unit tests failed']
          }
        ]
      };
      
      const report = reporter.buildValidationReport(mockResults);
      
      expect(report).toContain('# Validation Report');
      expect(report).toContain('Executive Summary');
      expect(report).toContain('Test Results Summary');
      expect(report).toContain('Feature Validation Results');
      expect(report).toContain('✅ PASSED FR-001');
      expect(report).toContain('❌ FAILED FR-002');
      expect(report).toContain('Recommendations');
    });

    test('should generate summary reports', () => {
      const reporter = new ValidationReporter();
      
      const mockResults = {
        total_features: 3,
        passed_features: 2,
        failed_features: 1,
        test_results: {
          unit: { total: 20, passed: 15, failed: 5, skipped: 0 }
        }
      };
      
      const summary = reporter.generateSummaryReport(mockResults);
      
      expect(summary).toContain('Validation Summary');
      expect(summary).toContain('Features: 2/3 passed');
      expect(summary).toContain('Unit Tests: 15/20 passed');
    });
  });

  describe('ValidationStateManager', () => {
    test('should update validation state correctly', async () => {
      const stateManager = new ValidationStateManager();
      
      const mockResults = {
        timestamp: new Date().toISOString(),
        total_features: 1,
        passed_features: 1,
        failed_features: 0,
        features: [
          {
            id: 'FR-001',
            name: 'Basic Task CRUD',
            passed: true,
            confidence_score: 0.9,
            validation_gates: {
              pre_implementation: true,
              implementation: true,
              post_implementation: true
            },
            test_results: {
              unit: { total: 10, passed: 10, failed: 0, skipped: 0 }
            }
          }
        ],
        test_results: {
          unit: { total: 10, passed: 10, failed: 0, skipped: 0 }
        }
      };
      
      // This would normally update actual state files
      // In a real test, we'd mock the file system operations
      await expect(stateManager.updateValidationState(mockResults, {})).resolves.not.toThrow();
    });

    test('should calculate overall test coverage correctly', () => {
      const stateManager = new ValidationStateManager();
      
      const coverage = stateManager.calculateOverallTestCoverage(
        10, 8,  // unit: 8/10 = 80%
        5, 4,   // integration: 4/5 = 80%
        2, 1    // bdd: 1/2 = 50%
      );
      
      // Expected: (80% * 0.6) + (80% * 0.3) + (50% * 0.1) = 48 + 24 + 5 = 77%
      expect(coverage).toBeCloseTo(77, 1);
    });
  });

  describe('IntegrationTestManager', () => {
    test('should initialize from registry', async () => {
      const integrationManager = await IntegrationTestManager.fromRegistry(mockRegistry);
      
      expect(integrationManager).toBeDefined();
      expect(integrationManager.registry).toEqual(mockRegistry);
    });

    test('should validate feature interactions', () => {
      const integrationManager = new IntegrationTestManager(mockRegistry);
      
      const validationResults = integrationManager.validateFeatureInteractions(['FR-001', 'FR-002']);
      
      expect(validationResults).toBeDefined();
      expect(validationResults.features).toEqual(['FR-001', 'FR-002']);
      expect(validationResults.interactions).toBeDefined();
    });

    test('should detect feature interactions correctly', () => {
      const integrationManager = new IntegrationTestManager(mockRegistry);
      
      const feature1 = mockRegistry.features.find(f => f.id === 'FR-001');
      const feature2 = mockRegistry.features.find(f => f.id === 'FR-002');
      
      const interacts = integrationManager.featuresInteract(feature1, feature2);
      
      // FR-002 depends on FR-001, so they should interact
      expect(interacts).toBe(true);
    });

    test('should generate integration tests', () => {
      const integrationManager = new IntegrationTestManager(mockRegistry);
      
      const generatedTests = integrationManager.generateIntegrationTests(mockRegistry.features);
      
      expect(generatedTests).toBeDefined();
      expect(Array.isArray(generatedTests)).toBe(true);
      expect(generatedTests.length).toBeGreaterThan(0);
    });
  });

  describe('End-to-End Validation Workflow', () => {
    test('should execute complete validation workflow', async () => {
      // 1. Initialize ValidationManager
      const validationManager = await ValidationManager.fromRegistry(mockRegistry);
      
      // 2. Run validation
      const validationResults = await validationManager.validateFeatures(['FR-001'], {
        integration: false,
        e2e: false
      });
      
      expect(validationResults).toBeDefined();
      expect(validationResults.total_features).toBe(1);
      
      // 3. Generate report
      const reportPath = validationManager.generateValidationReport(validationResults);
      expect(reportPath).toBeDefined();
      expect(typeof reportPath).toBe('string');
      
      // 4. Update state (would normally update files)
      const stateManager = new ValidationStateManager();
      await expect(stateManager.updateValidationState(validationResults, {})).resolves.not.toThrow();
    });

    test('should handle dependency-aware validation', async () => {
      const validationManager = await ValidationManager.fromRegistry(mockRegistry);
      
      // Validate FR-003 which depends on FR-001 and FR-002
      const validationResults = await validationManager.validateFeatures(['FR-003'], {});
      
      expect(validationResults).toBeDefined();
      expect(validationResults.total_features).toBe(1);
      expect(validationResults.features[0].id).toBe('FR-003');
    });

    test('should handle validation with all test types', async () => {
      const validationManager = await ValidationManager.fromRegistry(mockRegistry);
      
      const validationResults = await validationManager.validateFeatures(['FR-001'], {
        integration: true,
        e2e: true
      });
      
      expect(validationResults.test_results.unit).toBeDefined();
      expect(validationResults.test_results.integration).toBeDefined();
      expect(validationResults.test_results.e2e).toBeDefined();
    });
  });

  describe('Error Handling', () => {
    test('should handle missing feature registry gracefully', async () => {
      await expect(ValidationManager.fromRegistry(null)).rejects.toThrow();
    });

    test('should handle invalid feature IDs', async () => {
      const validationManager = await ValidationManager.fromRegistry(mockRegistry);
      
      const validationResults = await validationManager.validateFeatures(['FR-999'], {});
      
      expect(validationResults.skipped_features).toBe(1);
      expect(validationResults.total_features).toBe(1);
      expect(validationResults.passed_features).toBe(0);
    });

    test('should handle validation errors gracefully', async () => {
      const validationManager = await ValidationManager.fromRegistry(mockRegistry);
      
      // Mock a feature with a non-existent file path
      const invalidRegistry = {
        ...mockRegistry,
        features: [{
          ...mockRegistry.features[0],
          file_path: 'non-existent-file.md'
        }]
      };
      
      const invalidManager = await ValidationManager.fromRegistry(invalidRegistry);
      const validationResults = await invalidManager.validateFeatures(['FR-001'], {});
      
      expect(validationResults.features[0].validation_errors.length).toBeGreaterThan(0);
      expect(validationResults.features[0].passed).toBe(false);
    });
  });
});

// Test helper functions
function createMockFeatureFile(featureId, content = '') {
  const defaultContent = `# ${featureId}

## User Story
As a user, I want to test validation, so that I can ensure the system works correctly.

## Acceptance Criteria
1. The feature should be validated correctly
2. All tests should pass

## Validation Gates
- Pre-implementation: Requirements validated
- Implementation: Unit tests pass
- Post-implementation: Integration tests pass

${content}`;

  return defaultContent;
}

function createMockTestFile(featureId, shouldPass = true) {
  return `// Test file for ${featureId}
describe('${featureId}', () => {
  test('should work correctly', () => {
    expect(${shouldPass}).toBe(true);
  });
});`;
}